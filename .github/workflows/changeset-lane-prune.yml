name: Changeset Lane Prune

on:
  pull_request:
    types:
      - closed
    branches:
      - prev
      - main

concurrency:
  group: changeset-lane-prune-pr-${{ github.event.pull_request.number }}
  cancel-in-progress: true

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  prune:
    if: github.event.pull_request.merged == true && github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Resolve lane prune route
        id: route
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
        with:
          script: |
            const base = context.payload.pull_request.base.ref;
            const head = context.payload.pull_request.head.ref;
            let target = "";

            if (head === "dev" && base === "prev") {
              target = "dev";
            } else if (head === "prev" && base === "main") {
              target = "prev";
            }

            core.setOutput("enabled", target ? "true" : "false");
            core.setOutput("base", base);
            core.setOutput("head", head);
            core.setOutput("target", target);

      - name: Skip non-promotion flow
        if: steps.route.outputs.enabled != 'true'
        run: echo "Merged flow does not require changeset lane prune."

      - name: Create GitHub App token
        if: steps.route.outputs.enabled == 'true'
        id: app_token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf
        with:
          app-id: ${{ secrets.RELEASE_APP_ID }}
          private-key: ${{ secrets.RELEASE_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: ${{ github.event.repository.name }}

      - name: Checkout target lane
        if: steps.route.outputs.enabled == 'true'
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd
        with:
          fetch-depth: 0
          ref: ${{ steps.route.outputs.target }}

      - name: List merged PR changeset files
        if: steps.route.outputs.enabled == 'true'
        id: pr_files
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
        with:
          script: |
            const { owner, repo } = context.repo;
            const pull_number = context.payload.pull_request.number;
            const allowedStatuses = new Set(["added", "modified", "renamed", "copied"]);
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number,
              per_page: 100,
            });

            const candidates = new Set();
            for (const file of files) {
              const status = (file.status || "").toLowerCase();
              if (!allowedStatuses.has(status)) continue;
              const filename = (file.filename || "").trim();
              if (!filename.startsWith("Project/.changeset/")) continue;
              if (!filename.endsWith(".md")) continue;
              if (filename === "Project/.changeset/README.md") continue;
              candidates.add(filename);
            }

            const sorted = [...candidates].sort((a, b) => a.localeCompare(b));
            core.info(`Found ${sorted.length} candidate changeset files in merged PR #${pull_number}.`);
            core.setOutput("candidate_count", String(sorted.length));
            core.setOutput("candidate_paths", sorted.join("\n"));

      - name: Collect and apply prune candidates
        if: steps.route.outputs.enabled == 'true'
        id: collect
        shell: bash
        env:
          CANDIDATE_PATHS: ${{ steps.pr_files.outputs.candidate_paths }}
          PROMOTED_REF_PRIMARY: ${{ github.event.pull_request.merge_commit_sha }}
          PROMOTED_REF_FALLBACK: origin/${{ steps.route.outputs.base }}
          TARGET_REF: origin/${{ steps.route.outputs.target }}
        run: |
          set -euo pipefail

          promoted_ref="$PROMOTED_REF_PRIMARY"
          if [[ -z "$promoted_ref" ]]; then
            promoted_ref="$PROMOTED_REF_FALLBACK"
          fi
          echo "Using promoted ref: $promoted_ref"

          git fetch origin "${{ steps.route.outputs.base }}" "${{ steps.route.outputs.target }}" --depth=1

          tmpdir="$(mktemp -d)"
          candidate_file="$tmpdir/candidates.txt"
          delete_file="$tmpdir/delete.txt"
          skipped_file="$tmpdir/skipped.txt"
          : > "$candidate_file"
          : > "$delete_file"
          : > "$skipped_file"

          while IFS= read -r file_path; do
            [ -z "${file_path:-}" ] && continue
            echo "$file_path" >> "$candidate_file"
          done <<< "$CANDIDATE_PATHS"

          if [[ ! -s "$candidate_file" ]]; then
            echo "has_deletions=false" >> "$GITHUB_OUTPUT"
            {
              echo "deleted_lines<<EOF"
              echo "- _none_"
              echo "EOF"
              echo "skipped_lines<<EOF"
              echo "- _none_"
              echo "EOF"
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          sort -u "$candidate_file" -o "$candidate_file"

          while IFS= read -r file_path; do
            [ -z "$file_path" ] && continue

            promoted_blob="$(git rev-parse "${promoted_ref}:${file_path}" 2>/dev/null || true)"
            target_blob="$(git rev-parse "${TARGET_REF}:${file_path}" 2>/dev/null || true)"

            if [[ -z "$promoted_blob" ]]; then
              echo "- \`$file_path\` skipped: missing on promoted lane (\`${promoted_ref}\`)." >> "$skipped_file"
              continue
            fi
            if [[ -z "$target_blob" ]]; then
              echo "- \`$file_path\` skipped: already absent on target lane (\`${TARGET_REF}\`)." >> "$skipped_file"
              continue
            fi
            if [[ "$promoted_blob" != "$target_blob" ]]; then
              echo "- \`$file_path\` skipped: content mismatch between promoted and target lanes." >> "$skipped_file"
              continue
            fi

            git rm -- "$file_path"
            echo "- \`$file_path\`" >> "$delete_file"
          done < "$candidate_file"

          if [[ ! -s "$delete_file" ]]; then
            echo "has_deletions=false" >> "$GITHUB_OUTPUT"
            delete_line="- _none_"
          else
            echo "has_deletions=true" >> "$GITHUB_OUTPUT"
            delete_line="$(cat "$delete_file")"
          fi

          if [[ ! -s "$skipped_file" ]]; then
            skipped_line="- _none_"
          else
            skipped_line="$(cat "$skipped_file")"
          fi

          {
            echo "deleted_lines<<EOF"
            echo "$delete_line"
            echo "EOF"
            echo "skipped_lines<<EOF"
            echo "$skipped_line"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Skip when no matching consumed changesets were found
        if: steps.route.outputs.enabled == 'true' && steps.collect.outputs.has_deletions != 'true'
        run: echo "No deletions needed on target lane."

      - name: Open lane prune PR
        if: steps.route.outputs.enabled == 'true' && steps.collect.outputs.has_deletions == 'true'
        id: prune_pr
        uses: peter-evans/create-pull-request@22a9089034f40e5a961c8808d113e2c98fb63676
        with:
          token: ${{ steps.app_token.outputs.token }}
          commit-message: "chore(release): prune promoted changesets from ${{ steps.route.outputs.target }}"
          title: "chore(release): prune promoted changesets from ${{ steps.route.outputs.target }}"
          body: |
            Auto-generated changeset cleanup after merging #${{ github.event.pull_request.number }} (`${{ steps.route.outputs.head }} -> ${{ steps.route.outputs.base }}`).

            Files removed from `${{ steps.route.outputs.target }}` (content matched promoted lane):
            ${{ steps.collect.outputs.deleted_lines }}

            Files skipped:
            ${{ steps.collect.outputs.skipped_lines }}
          labels: |
            ignore-for-release
          branch: "changeset-sync/${{ steps.route.outputs.target }}/${{ github.event.pull_request.number }}-${{ github.run_id }}"
          base: ${{ steps.route.outputs.target }}
          delete-branch: true

      - name: Enable auto-merge for lane prune PR
        if: steps.prune_pr.outputs.pull-request-number != ''
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
        env:
          PR_NUMBER: ${{ steps.prune_pr.outputs.pull-request-number }}
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          script: |
            const prNumber = Number(process.env.PR_NUMBER || "0");
            if (!Number.isInteger(prNumber) || prNumber <= 0) {
              core.info("No lane prune PR number detected; skipping auto-merge enablement.");
              return;
            }

            const { owner, repo } = context.repo;
            const pr = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: prNumber,
            });
            const mergeImmediately = async () => {
              try {
                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: prNumber,
                  merge_method: "squash",
                });
                core.info(`Merged lane prune PR #${prNumber} with SQUASH.`);
              } catch (mergeError) {
                const mergeDetail = mergeError instanceof Error ? mergeError.message : String(mergeError);
                const lower = mergeDetail.toLowerCase();
                if (lower.includes("already merged")) {
                  core.info(`Lane prune PR #${prNumber} is already merged.`);
                  return;
                }
                throw mergeError;
              }
            };

            if (pr.data.merged) {
              core.info(`Lane prune PR #${prNumber} is already merged.`);
              return;
            }
            if (pr.data.auto_merge) {
              core.info(`Auto-merge already enabled for lane prune PR #${prNumber}.`);
              return;
            }
            if (pr.data.mergeable_state === "clean") {
              core.info(`Lane prune PR #${prNumber} is already mergeable; merging immediately with SQUASH.`);
              await mergeImmediately();
              return;
            }

            const mutation = `
              mutation EnableAutoMerge($pullRequestId: ID!) {
                enablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId, mergeMethod: SQUASH }) {
                  pullRequest {
                    number
                  }
                }
              }
            `;

            try {
              await github.graphql(mutation, { pullRequestId: pr.data.node_id });
              core.info(`Enabled auto-merge (SQUASH) for lane prune PR #${prNumber}.`);
            } catch (error) {
              const detail = error instanceof Error ? error.message : String(error);
              if (detail.toLowerCase().includes("clean status")) {
                core.info(`Lane prune PR #${prNumber} is already mergeable; merging immediately with SQUASH.`);
                await mergeImmediately();
                return;
              }
              core.setFailed(
                `Unable to enable auto-merge for lane prune PR #${prNumber}. Ensure repository auto-merge is enabled and branch protection permits bot auto-merge. Details: ${detail}`
              );
            }
